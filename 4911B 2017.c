#pragma config(Sensor, dgtl1,  RightGoalLimit, sensorTouch)
#pragma config(Sensor, dgtl2,  LeftGoalLimit,  sensorTouch)
#pragma config(Sensor, dgtl4,  LeftEncoder,    sensorRotation)
#pragma config(Sensor, dgtl5,  AutoA,          sensorDigitalIn)
#pragma config(Sensor, dgtl6,  AutoB,          sensorDigitalIn)
#pragma config(Sensor, dgtl7,  RightGoalLimitB, sensorTouch)
#pragma config(Sensor, dgtl8,  LeftGoalLimitB, sensorTouch)
#pragma config(Sensor, dgtl9,  RightEncoder,   sensorRotation)
#pragma config(Motor,  port2,           RightFront,    tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port3,           Grabber2,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           RightBack,     tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port5,           LeftBack,      tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port6,           LeftGoalLift,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RightGoalLift, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           Grabber,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           LeftFront,     tmotorVex393_MC29, openLoop)
#pragma config(DatalogSeries, 2, "", Sensors, Sensor, dgtl3, 50)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
	4911B 2017 main code
	Written by Andrew Jager
*/

#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//Include custom functions
#include "AutoFunctions4911B.c"
#include "SelfCheck.c"

//create variables
int ClawCount = 0;

//make code unreadable
#define Goto if
#define Dont else
#define StopCode while
#define Fake true
#define KillThread task
#define Piston motor

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;


}

task autonomous()
{
  Goto (SensorValue[AutoA] == 0 && SensorValue[AutoB] == 0){//Right auto
	//close claw
  Piston[Grabber] = 120;
  delay(350);

  //hold claw
  motor[Grabber] = 30;

  //drive
  DriveStraight(470,125,80,1,0);

  //raise lift
  AutoLift(1,127,10);

  //drive over goal
  AutoDrive(190,120,15,10);

  //drop lift
  AutoLift(1800,127,10);

  //drive back
  DriveStraight(790,-110,80,1,200);

  //raise lift
  AutoLift(1,127,10);

  //turn
  AutoTurn(2,1,80,100,400);

  //dive back more
  AutoDrive(10,-80,0,250);

  //open claw
  Piston[Grabber] = -127;

  //dive back more
  AutoDrive(100,-80,100,1);
 }
 Dont Goto (SensorValue[AutoA] == 0 && SensorValue[AutoB] == 1){//only cone
   //close claw
  Piston[Grabber] = 120;
  delay(350);

  //hold claw
  Piston[Grabber] = 30;

  //drive
  //AutoDrive(520,100,15,500);
  DriveStraight(500,100,80,1,500);

    //raise lift
  Piston[LeftGoalLift] = -127;
  Piston[RightGoalLift] = -127;
  delay(2800);

  //stop lift
  Piston[LeftGoalLift] = 0;
  Piston[RightGoalLift] = 0;

  //drive back
  AutoDrive(55,100,10,500);

  //drop lift
  Piston[LeftGoalLift] = 127;
  Piston[RightGoalLift] = 127;
  delay(600);

    //stop lift
  Piston[LeftGoalLift] = 0;
  Piston[RightGoalLift] = 0;

  //open claw
  Piston[Grabber] = -127;
  delay(350);

  Piston[Grabber] = 0;

  AutoDrive(40,-100,10,500);
 }
 Dont Goto (SensorValue[AutoA] == 1 && SensorValue[AutoB] == 0){//sabatoge
 AutoDrive(1500,100,0,0);
 }
 Dont Goto (SensorValue[AutoA] == 1 && SensorValue[AutoB] == 1){//left auto
	//close claw
  Piston[Grabber] = 120;
  delay(350);

  //hold claw
  Piston[Grabber] = 30;

  //drive
  DriveStraight(470,125,80,1,0);

  //raise lift
  AutoLift(1,127,10);

  //drive over goal
  AutoDrive(190,120,15,10);

  //drop lift
  AutoLift(1800,127,10);

  //drive back
  DriveStraight(790,-110,80,1,200);

  //raise lift
  AutoLift(1,127,10);

  //turn
  AutoTurn(1,1,80,100,400);

  //dive back more
  AutoDrive(10,-80,0,250);

  //open claw
  Piston[Grabber] = -127;

  //dive back more
  AutoDrive(100,-80,100,1);
}
}

KillThread usercontrol()
{
  // User control code here, inside the loop

  StopCode (Fake)
{

  //drive train code
  Piston[RightFront] = vexRT[Ch2];
  Piston[RightBack] = vexRT[Ch2];
  Piston[LeftFront] = vexRT[Ch3];
  Piston[LeftBack] = vexRT[Ch3];

  //goal lift code
//Right goal control
Goto (SensorValue[RightGoalLimitB] == false && vexRT[Btn6U] == true){
	motor[RightGoalLift] = vexRT[Btn6U]*-127;//raise motor
}
	Dont Goto(SensorValue[RightGoalLimit] == false && vexRT[Btn6D] == true){
		motor[RightGoalLift] = vexRT[Btn6D]*127;//lower motor
	}
		Dont{motor[RightGoalLift] = 0;}//stop motor

//left goal control
Goto (SensorValue[LeftGoalLimitB] == false && vexRT[Btn6U] == true){
	motor[LeftGoalLift] = vexRT[Btn6U]*-127;//raise motor
}
	Dont Goto (SensorValue[LeftGoalLimit] == false && vexRT[Btn6D] == true){
		motor[LeftGoalLift] = vexRT[Btn6D]*127;//lower motor
	}
		Dont{motor[LeftGoalLift] = 0;}//stop motor

//cone grabber code

Goto (vexRT[Btn5D] == true){
		motor[Grabber] = vexRT[Btn5D]*-127;
		ClawCount = 0; //reset
}
Dont Goto(ClawCount < 2000 && vexRT[Btn5U] == true){
	motor[Grabber] = vexRT[Btn5U]*127;//full power
	ClawCount = (ClawCount + 1);//increment
}
Dont Goto (ClawCount >= 2000 && vexRT[Btn5U] == true){
	motor[Grabber] = 20;//hold power
}
Dont{motor[Grabber]= 0;}//stop motor


//autonomous test code, comment out for competition
Goto (vexRT[Btn8D] == true  && vexRT[Btn8U] == true  && vexRT[Btn8L] == true && vexRT[Btn8R] == true){

	startTask(autonomous);
	delay(15000);
}
Dont{
	stopTask(autonomous);
}
  }
}
